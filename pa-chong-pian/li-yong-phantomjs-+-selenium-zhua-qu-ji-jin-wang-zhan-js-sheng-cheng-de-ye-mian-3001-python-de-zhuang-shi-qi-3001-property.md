### python的装饰器

我们玩魔兽争霸、Dota、王者农药、LOL的时候，如果英雄升级后乱加技能点或乱买装备，那么这个游戏还好玩吗？ —— 我们总希望留着技能点，在游戏的过程中按需分配：局势差的时候重生存，局势顺的时候重输出！

同样，在程序开发过程中，许多时候并不希望某个类 / 函数天生就非常庞大。一次性包含所有职能。那么我们就可以使用装饰者模式。可以随着需求和场景的变化。动态地给某个对象赋予一些额外的职能。而不会影响从这个类中派生的其他对象。

在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但继承的方式并不灵活，还会带来许多问题：

1、超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；

2、继承也被称为“白箱复用”，“白箱” 是相对可见性而言的，  
继承还会带来另外一个问题，在完成一些功能复用的同时，有可能创建出大量的子类，使子类的数量呈爆炸性增长。

比如现在有4种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3种配件。 

（要前灯不要尾灯，要尾灯不要前灯，要千灯和尾灯但不要铃铛，要铃铛但不要前灯和尾灯...）

 如果使用继承的方式来给每种自行车创建子类， 则需要 4×3 = 12 个子类。

 但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3个类。



